(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{436:function(v,_,e){"use strict";e.r(_);var t=e(0),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"node-js模块机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node-js模块机制"}},[v._v("#")]),v._v(" Node.js模块机制")]),v._v(" "),_("p",[v._v("[TOC]")]),v._v(" "),_("p",[v._v("https://juejin.cn/post/6844904030905303054")]),v._v(" "),_("p",[v._v("Nodejs遵循的是 CommonJS 规范，当我们 require('moduleA') 时，模块是怎么通过名字或者路径获取到模块的呢？首先要聊一下模块引用、模块定义、模块标识三个概念。")]),v._v(" "),_("h3",{attrs:{id:"commonjs规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#commonjs规范"}},[v._v("#")]),v._v(" CommonJS规范")]),v._v(" "),_("h4",{attrs:{id:"模块引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块引用"}},[v._v("#")]),v._v(" 模块引用")]),v._v(" "),_("p",[v._v("模块上下文提供"),_("code",[v._v("require()")]),v._v("方法来引入外部模块，看似简单的require函数， 其实内部做了大量工作。")]),v._v(" "),_("h4",{attrs:{id:"模块定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块定义"}},[v._v("#")]),v._v(" 模块定义")]),v._v(" "),_("p",[v._v("模块上下文提供了"),_("code",[v._v("exports")]),v._v("对象用于导入导出当前模块的方法或者变量，并且它是唯一的导出出口。模块中存在一个"),_("code",[v._v("module")]),v._v("对象，它代表模块自身，"),_("code",[v._v("exports")]),v._v("是module的属性。"),_("strong",[v._v("一个文件就是一个模块")]),v._v("，将方法作为属性挂载在exports上就可以定义导出的方式。")]),v._v(" "),_("h4",{attrs:{id:"模块标识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块标识"}},[v._v("#")]),v._v(" 模块标识")]),v._v(" "),_("p",[v._v("模块标识就是传递"),_("code",[v._v("给require()")]),v._v("方法的参数，它必须是符合小驼峰命名的字符串，或者以"),_("code",[v._v(".")]),v._v("、"),_("code",[v._v("..")]),v._v("开头的相对路径或者绝对路径，可以没有文件后缀名"),_("code",[v._v(".js")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"node的模块实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node的模块实现"}},[v._v("#")]),v._v(" Node的模块实现")]),v._v(" "),_("p",[v._v("路径分析 -> 文件定位 -> 编译执行 -> 加入内存")]),v._v(" "),_("h4",{attrs:{id:"路径分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#路径分析"}},[v._v("#")]),v._v(" 路径分析")]),v._v(" "),_("p",[v._v("Node.js中模块可以通过文件路径或名字获取模块的引用。"),_("strong",[v._v("模块的引用会映射到一个js文件路径")]),v._v("。 在Node中模块分为两类：")]),v._v(" "),_("ul",[_("li",[v._v("一是Node提供的模块，称为"),_("strong",[v._v("核心模块")]),v._v("（内置模块），内置模块公开了一些常用的API给开发者，并且它们在Node进程开始的时候就预加载了。")]),v._v(" "),_("li",[v._v("另一类是用户编写的模块，称为"),_("strong",[v._v("文件模块")]),v._v("。如通过NPM安装的第三方模块（third-party modules）或本地模块（local modules），每个模块都会暴露一个公开的API。以便开发者可以导入。")])]),v._v(" "),_("h4",{attrs:{id:"文件定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件定位"}},[v._v("#")]),v._v(" 文件定位")]),v._v(" "),_("p",[_("strong",[v._v("文件扩展名分析")])]),v._v(" "),_("p",[v._v("调用"),_("code",[v._v("require()")]),v._v("方法时若参数没有文件扩展名，Node会按"),_("code",[v._v(".js")]),v._v("、"),_("code",[v._v(".json")]),v._v("、"),_("code",[v._v(".node")]),v._v("的顺寻补足扩展名，依次尝试。")]),v._v(" "),_("p",[_("strong",[v._v("目录分析和包")])]),v._v(" "),_("p",[_("code",[v._v("require()")]),v._v("分析文件扩展名后，可能没有查到对应文件，而是找到了一个目录，此时Node会将目录当作一个包来处理。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/25/16f38d1d79c552e0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),v._v(" "),_("h4",{attrs:{id:"模块编译"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块编译"}},[v._v("#")]),v._v(" 模块编译")]),v._v(" "),_("p",[v._v("对于不同的文件，用不同的不同的是放载入")]),v._v(" "),_("ul",[_("li",[_("code",[v._v(".js")]),v._v("通过fs模块同步读取文件后编译执行。")]),v._v(" "),_("li",[_("code",[v._v(".node")]),v._v("这是C/C++编写的扩展文件，通过"),_("code",[v._v("dlopen()")]),v._v("方法加载最后编译生成的文件")]),v._v(" "),_("li",[_("code",[v._v(".json")]),v._v("同过fs模块同步读取文件后，用"),_("code",[v._v("JSON.pares()")]),v._v("解析返回结果")])]),v._v(" "),_("p",[_("strong",[v._v("核心模块编译")])]),v._v(" "),_("p",[v._v("核心模块分为"),_("code",[v._v("C/C++")]),v._v("编写和JavaScript编写的两个部分，其中"),_("code",[v._v("C/C++")]),v._v("文件放在Node项目的src目录下，JavaScript文件放在lib目录下。")]),v._v(" "),_("h3",{attrs:{id:"import和require"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#import和require"}},[v._v("#")]),v._v(" import和require")]),v._v(" "),_("p",[_("code",[v._v("import")]),v._v("是ES6的模块规范，"),_("code",[v._v("require")]),v._v("是commonjs的模块规范，详细的用法我不介绍，我只想说一下他们最基本的区别，"),_("strong",[v._v("import是静态加载模块，require是动态加载")])]),v._v(" "),_("p",[_("strong",[v._v("那么静态加载和动态加载的区别是什么呢")]),v._v("？")]),v._v(" "),_("p",[v._v("静态加载时代码在编译的时候已经执行了，动态加载是编译后在代码运行的时候再执行。")]),v._v(" "),_("h4",{attrs:{id:"require原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#require原理"}},[v._v("#")]),v._v(" require原理")]),v._v(" "),_("p",[v._v("http://www.ruanyifeng.com/blog/2015/05/require.html")]),v._v(" "),_("p",[v._v("当 Node 遇到 require(X) 时，按下面的顺序处理。")]),v._v(" "),_("p",[v._v("（1）如果 X 是内置模块（比如 require('http'）)\n　　a. 返回该模块。\n　　b. 不再继续执行。")]),v._v(" "),_("p",[v._v('（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头\n　　a. 根据 X 所在的父模块，确定 X 的绝对路径。\n　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。')]),v._v(" "),_("p",[v._v("​\t\t\tX \tX.js\tX.json\tX.node")]),v._v(" "),_("p",[v._v("c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。")]),v._v(" "),_("p",[v._v("​\t\t\tX/package.json（main字段）\tX/index.js\tX/index.json\t\tX/index.node")]),v._v(" "),_("p",[v._v("（3）如果 X 不带路径\n　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。\n　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。")]),v._v(" "),_("p",[v._v('（4） 抛出 "not found"')])])}),[],!1,null,null,null);_.default=r.exports}}]);