(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{474:function(v,_,e){"use strict";e.r(_);var t=e(0),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"三次握手四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手四次挥手"}},[v._v("#")]),v._v(" 三次握手四次挥手")]),v._v(" "),_("h3",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Client给Server发送报文，Server知道自己能接收到Client发送的报文")]),v._v(" "),_("p",[v._v("该报文的SYN = 1， seq = x")])]),v._v(" "),_("li",[_("p",[v._v("Server给Client发送报文，Client知道自己能接收Server发送的报文，知道自己发送的报文能被Server接收")]),v._v(" "),_("p",[v._v("该报文的SYN = 1, ACK = 1，确认号 = x + 1， seq = y")])]),v._v(" "),_("li",[_("p",[v._v("Client给Server发送报文，Server知道自己发送的报文能被Client接收。")]),v._v(" "),_("p",[v._v("该报文的ACK = 1，确认号 = y + 1")])])]),v._v(" "),_("p",[v._v("经过三次握手，客户端（Client）和服务端（Server）都知道自己发送的报文能被对方接收，也知道自己能接收到对方的报文。")]),v._v(" "),_("p",[v._v("注：SYN / ACK / FIN 为TCP报文头部的一个标识。seq为报文的序列号（Sequence number），ack为报文的确认序号（并不是之前那个标识，而是Acknowledgement Number）。")]),v._v(" "),_("p",[v._v("SYN = 1，seq = x 对应的是 ACK = 1，ack = x + 1")]),v._v(" "),_("p",[_("strong",[v._v("为什么不两次握手")])]),v._v(" "),_("blockquote",[_("p",[v._v("主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。")])]),v._v(" "),_("p",[v._v("假设有这样一种场景, 客户端发送的第一个请求连接并且没有丢失，但是被滞留的时间太长。由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送报文。 而现在第一个请求到达服务端，这个请求已经报废了，但是又会建立连接。")]),v._v(" "),_("p",[v._v("如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。")]),v._v(" "),_("p",[_("strong",[v._v("为什么不四次握手")])]),v._v(" "),_("p",[v._v("既然三次就可以了，多一次就是浪费资源了。")]),v._v(" "),_("h3",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[v._v("#")]),v._v(" 四次挥手")]),v._v(" "),_("p",[v._v("TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。")]),v._v(" "),_("ul",[_("li",[v._v("第一次挥手\n"),_("ul",[_("li",[v._v("若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。")])])]),v._v(" "),_("li",[v._v("第二次挥手\n"),_("ul",[_("li",[v._v("B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 "),_("strong",[v._v("CLOSE_WAIT")]),v._v(" 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 "),_("strong",[v._v("TCP 连接时双向的")]),v._v("，所以 B 仍旧可以发送数据给 A。")])])]),v._v(" "),_("li",[v._v("第三次挥手\n"),_("ul",[_("li",[v._v("B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入"),_("strong",[v._v("LAST-ACK")]),v._v("状态。")]),v._v(" "),_("li",[v._v("PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。")])])]),v._v(" "),_("li",[v._v("第四次挥手\n"),_("ul",[_("li",[v._v("A 收到释放请求后，向 B 发送确认应答，此时 A 进入 "),_("strong",[v._v("TIME-WAIT")]),v._v(" 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 "),_("strong",[v._v("CLOSED")]),v._v(" 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。")])])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://user-images.githubusercontent.com/52552604/125627029-def5de44-8413-492d-aa75-ebe269272b27.png",alt:"image"}})])])}),[],!1,null,null,null);_.default=r.exports}}]);