(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{435:function(t,s,e){"use strict";e.r(s);var a=e(0),n=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"node-js事件循环机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-js事件循环机制"}},[t._v("#")]),t._v(" Node.js事件循环机制")]),t._v(" "),s("p",[t._v("https://learnku.com/articles/38802")]),t._v(" "),s("p",[t._v("Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）")]),t._v(" "),s("h3",{attrs:{id:"nodejs的运行机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodejs的运行机制"}},[t._v("#")]),t._v(" Nodejs的运行机制")]),t._v(" "),s("ul",[s("li",[t._v("V8引擎解析JavaScript脚本。")]),t._v(" "),s("li",[t._v("解析后的代码，调用Node API")]),t._v(" "),s("li",[t._v("libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。")]),t._v(" "),s("li",[t._v("V8引擎再将结果返回给用户")])]),t._v(" "),s("h3",{attrs:{id:"事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n")])])]),s("p",[t._v("每个阶段都有一个要执行的回调 FIFO 队列。 尽管每个阶段都有其自己的特殊方式，但是通常，当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或执行回调的最大数量为止。 当队列已为空或达到回调限制时，事件循环将移至下一个阶段，依此类推。")]),t._v(" "),s("ol",[s("li",[t._v("timers：此阶段执行由 setTimeout 和 setInterval 设置的回调")]),t._v(" "),s("li",[t._v("pending callbacks：执行推迟到下一个循环迭代的 I/O 回调")]),t._v(" "),s("li",[t._v("idle, prepare, ：仅在内部使用")]),t._v(" "),s("li",[t._v("poll：取出新完成的 I/O 事件；执行与 I/O 相关的回调（除了关闭回调，计时器调度的回调和 setImmediate 之外，几乎所有这些回调） 适当时，node 将在此处阻塞")]),t._v(" "),s("li",[t._v("check：在这里调用 setImmediate 回调")]),t._v(" "),s("li",[t._v("close callbacks：一些关闭回调，例如 socket.on('close', ...)")])]),t._v(" "),s("p",[s("strong",[t._v("详细分析")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("主线程执行代码（V8上），能够触发各种异步任务：")]),t._v(" "),s("ul",[s("li",[t._v("宏任务：I/O，setTimeout、setInterval、setImmediate（script本身是宏任务）")]),t._v(" "),s("li",[t._v("微任务：process.nextTick、promise （process.nextTick在 promise之前执行，即先执行完所有的 process.nextTick 的任务，再执行完所有的 promise 任务")])])]),t._v(" "),s("li",[s("p",[t._v("主线程执行完成，进入第一阶段：timers（setTimeout、setInterval），主要检查是否有定时器计时超过对应的阈值，注意，在这个阶段，定时器的数据结构是最小堆，根据设置的阈值就知道谁的执行顺序先。直到执行所有的定时器回调，才执行微任务，进入下一阶段")])]),t._v(" "),s("li",[s("p",[t._v("pending callbacks / I/O callbacks，检查I/O队列（上一轮poll留下来），比如文件读取、写入，执行I/O任务，执行微任务，进入下一阶段")])]),t._v(" "),s("li",[s("p",[t._v("idle, prepare 是内部的实现，没必要讨论")])]),t._v(" "),s("li",[s("p",[t._v("poll轮询阶段，为啥需要它？")]),t._v(" "),s("ul",[s("li",[t._v("timer 阶段和 pending callbacks 阶段有各种回调（包括微任务），这些回调也是能够触发异步任务，因此，即使当 pending callbacks 完成所有微任务后，I/O队列和定时器队列还是存在大量的任务等待执行")]),t._v(" "),s("li",[t._v("poll 首先查看 是否存在已经超时的定时器，存在，回到timer阶段重新走（这个只会在进入poll的时候，做一次判断）")]),t._v(" "),s("li",[t._v("poll 发现没有超时的定时器，查看I/O队列是否存在任务，执行任务队列的任务，但是，每执行完成一个任务就执行所有的微任务")]),t._v(" "),s("li",[t._v("poll 执行完任务发现为空，那么检查是否存在setImmediate任务注册，如果存在那么结束poll，进入 下一阶段")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("注意 pending callbacks 和 poll 阶段是核心，他们都处理I/O回调 => 本质上是共用一个I/O任务队列，但是 pending callbacks 不负责收集 I/O回调 到 I/O任务队列，而poll能 够收集，因此 pending callbacks 只能在每次在执行完成 poll 后的下一轮事件循环（poll是有最长执行时间和最大执行回调个数，到了限制之后，即使I/O队列还存在任务也得退出，进行到下一阶段）")])]),t._v(" "),s("ul",[s("li",[t._v("check 执行 setImmediate")]),t._v(" "),s("li",[t._v("close callbacks  执行关闭回调")])]),t._v(" "),s("h3",{attrs:{id:"settimeout-vs-setimmediate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-vs-setimmediate"}},[t._v("#")]),t._v(" setTimeout VS setImmediate")]),t._v(" "),s("p",[t._v("如果你把这两个函数放入一个 I/O 循环内调用，setImmediate 总是被优先调用")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// timeout_vs_immediate.js")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fs'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nfs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("readFile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'timeout'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setImmediate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'immediate'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n$ node timeout_vs_immediate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\nimmediate\ntimeout\n")])])]),s("p",[t._v("与 "),s("code",[t._v("setTimeout")]),t._v(" 相比，使用 "),s("code",[t._v("setImmediate")]),t._v(" 的主要优点是，如果在 "),s("code",[t._v("I/O")]),t._v(" 周期内 "),s("code",[t._v("setImmediate")]),t._v(" 总是比任何 "),s("code",[t._v("timers")]),t._v(" 快，"),s("code",[t._v("poll")]),t._v(" 阶段用 "),s("code",[t._v("setImmediate")]),t._v(" 设置下阶段 "),s("code",[t._v("check")]),t._v(" 的回调，等到了 "),s("code",[t._v("check")]),t._v(" 就开始执行；"),s("code",[t._v("timers")]),t._v(" 阶段只能等到下次循环执行！")]),t._v(" "),s("p",[s("strong",[t._v("那为什么在外部 (比如主代码部分 mainline) 这两者的执行顺序不确定呢？")])]),t._v(" "),s("p",[t._v("在 mainline 部分执行 setTimeout 设置定时器 (没有写入队列呦)，与 setImmediate 写入 check 队列。mainline 执行完开始事件循环，第一阶段是 timers，这时候 timers 队列可能为空，也可能有回调；如果没有那么执行 check 队列的回调，下一轮循环在检查并执行 timers 队列的回调；如果有就先执行 timers 的回调，再执行 check 阶段的回调。因此这是 timers 的不确定性导致的。")])])}),[],!1,null,null,null);s.default=n.exports}}]);