(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{444:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" ES6+")]),t._v(" "),s("p",[t._v("[TOC]")]),t._v(" "),s("h3",{attrs:{id:"let、var、const的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let、var、const的区别"}},[t._v("#")]),t._v(" Let、Var、Const的区别")]),t._v(" "),s("ul",[s("li",[t._v("var可重复声明，let和const不行")]),t._v(" "),s("li",[t._v("变量提升，var会存在变量提升，let和const会有临时性死区，在声明之前访问变量报错")]),t._v(" "),s("li",[t._v("块级作用域，let 和 const 只在代码块内有效，var声明变量绑定到window 上")])]),t._v(" "),s("h3",{attrs:{id:"symbol"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[t._v("#")]),t._v(" Symbol")]),t._v(" "),s("ul",[s("li",[t._v("不是构造函数，不能通过new创建。而是直接调用Symbol()，返回的变量值永远不同")]),t._v(" "),s("li",[t._v("Symbol.for()全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索")]),t._v(" "),s("li",[t._v("Symbol.keyFor(参数为Symbol变量) 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。")])]),t._v(" "),s("h3",{attrs:{id:"map和-set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map和-set"}},[t._v("#")]),t._v(" Map和 Set")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Map是一个映射数据结构")]),t._v(" "),s("p",[t._v("**API：**Get、Set、Delete、Has(键)、Clear、Size、可以forEach遍历")])]),t._v(" "),s("li",[s("p",[t._v("Set是一个集合数据结构（自带去重效果）")]),t._v(" "),s("p",[s("strong",[t._v("API：")]),t._v(" Add、Has、Delete、Clear")])])]),t._v(" "),s("h3",{attrs:{id:"函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),s("p",[t._v("默认参数，参数临死性死区 ，不定参数符\n箭头函数，其中包括this的指向问题，参数表示")]),t._v(" "),s("h3",{attrs:{id:"数组api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组api"}},[t._v("#")]),t._v(" 数组API")]),t._v(" "),s("p",[t._v("Array.of 参数中所有值作为元素形成数组\nArray.from 将类数组对象或可迭代对象转化为数组\nfind、findIndex、fill、includes、flat、flatMap")]),t._v(" "),s("h3",{attrs:{id:"promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),s("p",[s("strong",[t._v("定义：")])]),t._v(" "),s("p",[t._v("是一种异步编程的解决方案，能够将异步操作封装，并将其返回的结果或者错误原因同Promise实例的then方法传入的处理函数联系起来")]),t._v(" "),s("p",[s("strong",[t._v("New Promise：")]),t._v("\n传入构造器函数，两个参数，都是敲定函数，第一个成功的敲定，第二个失败的敲定，构造器同步执行，但是可以异步的执行敲定函数\n构造器中调用对应的敲定函数，返回的promise实例的对象状态就是那种，当然中间能会抛出异常throw，那么…状态是拒绝\n状态的变化只有两种 pending => fulfilled，pending => rejected，一旦发生变化就不会再改变\n"),s("strong",[t._v("Promise.then返回的Promise的状态：")]),t._v("\n非Promise对象，直接包裹成为Promise（Promise.resolve）\nPromise对象，状态跟随，值跟随 ，通过这一点可以串联Promise（构造器函数的成功敲定函数也是这样的功能）\n报错返回拒绝的Promise，错误对象是Promise的错误原因\n"),s("strong",[t._v("异常穿透：")]),t._v("\n如果实例.then方法没有处理实例状态对于的回调函数，那么.then返回的promise实例状态跟随调用then方法的promise，Catch在最后进行异常的捕获")]),t._v(" "),s("p",[s("strong",[t._v("中断Promise链：")]),t._v("\n处理函数返回等待状态的Promise")]),t._v(" "),s("p",[s("strong",[t._v("判断Promise的执行顺序")]),t._v("\n注意，知道前面的Promise状态发生变化时，才能放进微任务队列\nasync 返回 Promise 和 promise.then返回 Promise 都会导致中间有两个层级的微任务队列间隔\nasync 每有await延后一个层次发生，如果返回promise再加两个层级")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nPromise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这两个promise的then发生的层级一致")]),t._v("\n")])])]),s("h3",{attrs:{id:"迭代器iterator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#迭代器iterator"}},[t._v("#")]),t._v(" 迭代器Iterator")]),t._v(" "),s("p",[t._v("Iterator是一种接口，它为不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator 接口，就可以完成遍历操作。")]),t._v(" "),s("p",[t._v("Iterator可以认为是一个"),s("strong",[t._v("指针")]),t._v("对象，通过next方法对数据结构进行遍历，每次调用next方法，指针就指向数组的下一个成员并返回数据结构的当前成员的信息。该信息是一个对象，包含value和done两个属性。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。")]),t._v(" "),s("p",[s("strong",[t._v("Iterator 接口部署在数据结构的Symbol.iterator属性")])]),t._v(" "),s("p",[t._v("可迭代的数据结构： String、Array、Map、Set、类数组、DOM（Nodelist对象）")]),t._v(" "),s("p",[t._v("目的就是为了迭代有序的数据结构，方便访问和使用"),s("strong",[t._v("for…of")])]),t._v(" "),s("h3",{attrs:{id:"生成器generator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成器generator"}},[t._v("#")]),t._v(" 生成器Generator")]),t._v(" "),s("ul",[s("li",[t._v("function关键字与函数名之间有一个星号。")]),t._v(" "),s("li",[t._v("函数体内部使用yield表达式划分不同部状态。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 得到遍历器对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" g "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: 1, done: false }")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: 2, done: false }")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: undefined, done: true }")]),t._v("\n")])])]),s("h3",{attrs:{id:"yield-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#yield-函数"}},[t._v("#")]),t._v(" Yield 函数")]),t._v(" "),s("p",[t._v("yield表达式就是用来"),s("strong",[t._v("划分Generator 函数的各个状态，他可以理解为函数暂停的标志")]),t._v("。")]),t._v(" "),s("p",[t._v("当执行next()方法，遇到yield表达式时，就暂停执行后面的操作，并"),s("strong",[t._v("将yield表达式的值作为next方法返回的信息对象的value属性值")]),t._v("。")]),t._v(" "),s("p",[t._v("下次调用next()方法，继续执行yield表达式后面的操作。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 得到遍历器对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" g "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: 3, done: false }")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: 5, done: false }")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: undefined, done: true }")]),t._v("\n")])])]),s("h3",{attrs:{id:"async、await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async、await"}},[t._v("#")]),t._v(" Async、Await")]),t._v(" "),s("p",[t._v("和Promise，Generator 有很大关联的：")]),t._v(" "),s("p",[t._v("Async函数返回一个Promise，await可以等待Promise实例状态敲定，自己进行迭代器的next方法")]),t._v(" "),s("h3",{attrs:{id:"proxy-和-reflect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proxy-和-reflect"}},[t._v("#")]),t._v(" Proxy 和 Reflect")]),t._v(" "),s("p",[s("strong",[t._v("Proxy")])]),t._v(" "),s("p",[t._v("Proxy 构造函数用于创建一个参数对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等")]),t._v(" "),s("p",[s("strong",[t._v("Reflect")])]),t._v(" "),s("p",[t._v("ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。")]),t._v(" "),s("p",[t._v("Reflect 对象对某些方法的返回结果进行了修改，使其更合理。")]),t._v(" "),s("p",[t._v("Reflect 对象使用函数的方式实现了 Object 的命令式操作")])])}),[],!1,null,null,null);s.default=e.exports}}]);