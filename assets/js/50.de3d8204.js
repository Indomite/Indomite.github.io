(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{459:function(e,a,t){"use strict";t.r(a);var r=t(0),s=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"深入浅出babel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入浅出babel"}},[e._v("#")]),e._v(" 深入浅出Babel")]),e._v(" "),a("p",[e._v("在现代JavaScript中babel的作用可谓是举足轻重，无论是工程化通过babel进行编码，还是说在ES6中通过babel转码编译，作为一个工具链，主要用于在当前和旧的浏览器或环境中，将 ECMAScript 2015+ 代码转换为 JavaScript 向后兼容版本的代码。")]),e._v(" "),a("ul",[a("li",[e._v("转换语法")]),e._v(" "),a("li",[e._v("Polyfill 目标环境中缺少的功能（通过如 "),a("a",{attrs:{href:"https://github.com/zloirock/core-js",target:"_blank",rel:"noopener noreferrer"}},[e._v("core-js"),a("OutboundLink")],1),e._v(" 的第三方 "),a("code",[e._v("polyfill")]),e._v("）")]),e._v(" "),a("li",[e._v("源代码转换(codemods)")])]),e._v(" "),a("h3",{attrs:{id:"babel的处理流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel的处理流程"}},[e._v("#")]),e._v(" Babel的处理流程")]),e._v(" "),a("p",[e._v("https://bobi.ink/2019/10/01/babel/")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("词法解析(Lexical Analysis)")]),e._v("： 词法解析器(Tokenizer)在这个阶段将字符串形式的代码转换为Tokens(令牌). Tokens 可以视作是一些语法片段组成的数组.每个 Token 中包含了语法片段、位置信息、以及一些类型信息. 这些信息有助于后续的语法分析。")])]),e._v(" "),a("li",[a("p",[e._v("语法解析器(Parser)会把Tokens转换为抽象语法树(Abstract Syntax Tree，AST)")]),e._v(" "),a("p",[a("strong",[e._v("AST 是 Babel 转译的核心数据结构，后续的操作都依赖于 AST")]),e._v("。")])]),e._v(" "),a("li",[a("p",[e._v("接着就是**转换(Transform)**了，转换阶段会对 AST 进行遍历，在这个过程中对节点进行增删查改。Babel 所有插件都是在这个阶段工作, 比如语法转换、代码压缩。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Javascript In Javascript Out")]),e._v(", 最后阶段还是要把 AST 转换回字符串形式的Javascript，同时这个阶段还会生成Source Map。")])])]),e._v(" "),a("h3",{attrs:{id:"babel的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel的架构"}},[e._v("#")]),e._v(" Babel的架构")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://bobi.ink/images/babel/arch.png",alt:"img"}})]),e._v(" "),a("h4",{attrs:{id:"babel核心"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel核心"}},[e._v("#")]),e._v(" babel核心")]),e._v(" "),a("p",[a("code",[e._v("@babel/core")]),e._v(" 对于Babel来说，这个内核主要干这些事情：")]),e._v(" "),a("ul",[a("li",[e._v("加载和处理配置(config)")]),e._v(" "),a("li",[e._v("加载插件")]),e._v(" "),a("li",[e._v("调用 "),a("code",[e._v("Parser")]),e._v(" 进行语法解析，生成 "),a("code",[e._v("AST")])]),e._v(" "),a("li",[e._v("调用 "),a("code",[e._v("Traverser")]),e._v(" 遍历AST，并使用访问者模式应用’插件’对 AST 进行转换")]),e._v(" "),a("li",[e._v("生成代码，包括SourceMap转换和源代码生成")])]),e._v(" "),a("h4",{attrs:{id:"核心周边支撑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心周边支撑"}},[e._v("#")]),e._v(" 核心周边支撑")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Parser("),a("code",[e._v("@babel/parser")]),e._v(")")]),e._v("： 将源代码解析为 AST 就靠它了。 它已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的ECMAScript规范。目前为了执行效率，parser是"),a("a",{attrs:{href:"https://babeljs.io/docs/en/babel-parser#faq",target:"_blank",rel:"noopener noreferrer"}},[e._v("不支持扩展的"),a("OutboundLink")],1),e._v("，由官方进行维护。如果你要支持自定义语法，可以 fork 它，不过这种场景非常少。")]),e._v(" "),a("li",[a("strong",[e._v("Traverser("),a("code",[e._v("@babel/traverse")]),e._v(")")]),e._v("： 实现了"),a("code",[e._v("访问者模式")]),e._v("，对 AST 进行遍历，"),a("code",[e._v("转换插件")]),e._v("会通过它获取感兴趣的AST节点，对节点继续操作, 下文会详细介绍"),a("code",[e._v("访问器模式")]),e._v("。")]),e._v(" "),a("li",[a("strong",[e._v("Generator("),a("code",[e._v("@babel/generator")]),e._v(")")]),e._v("： 将 AST 转换为源代码，支持 SourceMap")])]),e._v(" "),a("h4",{attrs:{id:"插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件"}},[e._v("#")]),e._v(" 插件")]),e._v(" "),a("ul",[a("li",[a("p",[a("strong",[e._v("语法插件("),a("code",[e._v("@babel/plugin-syntax-\\*")]),e._v(")")]),e._v("：上面说了 "),a("code",[e._v("@babel/parser")]),e._v(" 已经支持了很多 JavaScript 语法特性，Parser也不支持扩展. "),a("strong",[e._v("因此"),a("code",[e._v("plugin-syntax-\\*")]),e._v("实际上只是用于开启或者配置Parser的某个功能特性")]),e._v("。")]),e._v(" "),a("p",[e._v("一般用户不需要关心这个，Transform 插件里面已经包含了相关的"),a("code",[e._v("plugin-syntax-*")]),e._v("插件了。用户也可以通过"),a("a",{attrs:{href:"https://babeljs.io/docs/en/options#parseropts",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("parserOpts")]),a("OutboundLink")],1),e._v("配置项来直接配置 Parser")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("转换插件")]),e._v("： 用于对 AST 进行转换, 实现转换为ES5代码、压缩、功能增强等目的. Babel仓库将转换插件划分为两种(只是命名上的区别)：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("@babel/plugin-transform-*")]),e._v("： 普通的转换插件")]),e._v(" "),a("li",[a("code",[e._v("@babel/plugin-proposal-*")]),e._v("： 还在’提议阶段’(非正式)的语言特性, 目前有"),a("a",{attrs:{href:"https://babeljs.io/docs/en/next/plugins#experimental",target:"_blank",rel:"noopener noreferrer"}},[e._v("这些"),a("OutboundLink")],1)])])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("预定义集合("),a("code",[e._v("@babel/presets-\\*")]),e._v(")")]),e._v("： 插件集合或者分组，主要方便用户对插件进行管理和使用。比如"),a("code",[e._v("preset-env")]),e._v("含括所有的标准的最新特性; 再比如"),a("code",[e._v("preset-react")]),e._v("含括所有react相关的插件")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("@babel/template")]),e._v("： 某些场景直接操作AST太麻烦，就比如我们直接操作DOM一样，所以Babel实现了这么一个简单的模板引擎，可以将字符串代码转换为AST。比如在生成一些辅助代码(helper)时会用到这个库")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("@babel/types")]),e._v("： AST 节点构造器和断言. 插件开发时使用很频繁")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("@babel/helper-*")]),e._v("： 一些辅助器，用于辅助插件开发，例如简化AST操作")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("@babel/helper")]),e._v("： 辅助代码，单纯的语法转换可能无法让代码运行起来，比如低版本浏览器无法识别class关键字，这时候需要添加辅助代码，对class进行模拟。")])])]),e._v(" "),a("p",[a("strong",[e._v("访问者模式")])]),e._v(" "),a("p",[e._v("想象一下，Babel 有那么多插件，如果每个插件自己去遍历AST，对不同的节点进行不同的操作，维护自己的状态。这样子不仅低效，它们的逻辑分散在各处，会让整个系统变得难以理解和调试， 最后插件之间关系就纠缠不清，乱成一锅粥。")]),e._v(" "),a("p",[a("strong",[e._v("所以转换器操作 AST 一般都是使用"),a("code",[e._v("访问器模式")]),e._v("，由这个"),a("code",[e._v("访问者(Visitor)")]),e._v("来 ① 进行统一的遍历操作，② 提供节点的操作方法，③ 响应式维护节点之间的关系；而插件(设计模式中称为‘具体访问者’)只需要定义自己感兴趣的节点类型，当访问者访问到对应节点时，就调用插件的访问(visit)方法")]),e._v("。")]),e._v(" "),a("h4",{attrs:{id:"事例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事例"}},[e._v("#")]),e._v(" 事例：")]),e._v(" "),a("p",[e._v("代码：")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("hello")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("v")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'hello'")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" v "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'!'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("解析的AST：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("File\n  Program (program)\n    FunctionDeclaration (body)\n      Identifier (id)  #hello\n      Identifier (params[0]) #v\n      BlockStatement (body)\n        ExpressionStatement ([0])\n          CallExpression (expression)\n            MemberExpression (callee)  #console.log\n              Identifier (object)  #console\n              Identifier (property)  #log\n            BinaryExpression (arguments[0])\n              BinaryExpression (left)\n                StringLiteral (left)  #'hello'\n                Identifier (right)  #v\n              StringLiteral (right)  #'!'\n")])])]),a("p",[e._v("调用顺序：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://bobi.ink/images/babel/traveser.png",alt:"img"}})])])}),[],!1,null,null,null);a.default=s.exports}}]);